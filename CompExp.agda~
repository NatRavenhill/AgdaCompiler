module CompExp where

open import IO
open import Data.Nat
open import Data.Bool renaming (Bool to ùîπ; _‚àß_ to oldand)
open import Data.List 
open import Data.Product
open import Relation.Binary.PropositionalEquality renaming ([_] to ‚ü™_‚ü´)
open import Data.Maybe
open import Data.String renaming (_++_ to _^_; show to strshow)
open import Data.Nat.Show

data instr : Set where
  Var  : String ‚Üí instr
  Val  : ‚Ñï ‚Üí instr
  Add  : instr
  Not : instr
  Sub  : instr
  Joz  : ‚Ñï ‚Üí instr
  Err  : instr

program = List instr
stack   = List ‚Ñï
state   = String ‚Üí Maybe ‚Ñï 


notB : ùîπ -> ùîπ
notB true = false
notB false = true

-- Not for natural numbers.
notN : ‚Ñï -> ‚Ñï
notN zero = suc zero
notN (suc n) = zero


‚ü®‚ü®_‚ü©‚ü©_,_,_ : program ‚Üí stack ‚Üí state ‚Üí ‚Ñï ‚Üí Maybe stack 
‚ü®‚ü® [] ‚ü©‚ü© s , _ , _                         = just s
‚ü®‚ü® _ ‚ü©‚ü© s , _ , zero                       = just s
‚ü®‚ü® Val x ‚à∑ p ‚ü©‚ü© s , œÉ , suc k              = ‚ü®‚ü® p ‚ü©‚ü© (x ‚à∑ s) , œÉ , k 
‚ü®‚ü® Var x ‚à∑ p ‚ü©‚ü© s , œÉ , suc k with œÉ x
...                            | just v  = ‚ü®‚ü® p ‚ü©‚ü© (v ‚à∑ s) , œÉ , k
...                            | nothing = nothing
‚ü®‚ü® Add ‚à∑ p ‚ü©‚ü© (m ‚à∑ n ‚à∑ s) , œÉ , suc k      = ‚ü®‚ü® p ‚ü©‚ü© (m + n ‚à∑ s) , œÉ , k
‚ü®‚ü® Sub ‚à∑ p ‚ü©‚ü© (m ‚à∑ n ‚à∑ s) , œÉ , suc k      = ‚ü®‚ü® p ‚ü©‚ü© (m ‚à∏ n ‚à∑ s) , œÉ , k
‚ü®‚ü® Not ‚à∑ p ‚ü©‚ü© (b ‚à∑ s) , œÉ , suc k              = ‚ü®‚ü® p ‚ü©‚ü© (notN b ‚à∑ s) , œÉ , k
‚ü®‚ü® Joz n ‚à∑ p ‚ü©‚ü© (zero  ‚à∑ s) , œÉ , suc k    = ‚ü®‚ü® drop n p ‚ü©‚ü© s , œÉ , k
‚ü®‚ü® Joz _ ‚à∑ p ‚ü©‚ü© (suc _ ‚à∑ s) , œÉ , suc k    = ‚ü®‚ü® p ‚ü©‚ü© s , œÉ , k
‚ü®‚ü® _ ‚ü©‚ü© _ , _ , _ = nothing 


data Exp : (A : Set) ‚Üí Set where
  B   : ùîπ ‚Üí Exp ùîπ
  N   : ‚Ñï ‚Üí Exp ‚Ñï
  V   : String ‚Üí Exp ‚Ñï 
  _‚äï_ : Exp ‚Ñï ‚Üí Exp ‚Ñï ‚Üí Exp ‚Ñï
-- 1. minus,
-- 2. and, or, not 

-- ‚â§ ‚â• =

  if_then_else : Exp ‚Ñï ‚Üí Exp ‚Ñï ‚Üí Exp ‚Ñï ‚Üí Exp ‚Ñï


-- 3. if then else, short-cut logical operators


-- 4. times, divide (short-cut?) ... we have no loops though! how would you extend the machine?
--           simple extension : more operations (boring)
--           complex extension : more control
infixl 5 _‚äï_


‚ü¶_‚üß : ‚àÄ {T} ‚Üí Exp T ‚Üí state ‚Üí Maybe ‚Ñï
‚ü¶ B( true ) ‚üß œÉ = just (suc zero)
‚ü¶ B( false ) ‚üß œÉ = just zero
‚ü¶ N(v) ‚üß œÉ = just v
‚ü¶ V(s) ‚üß œÉ = œÉ s
‚ü¶ E ‚äï E' ‚üß œÉ = ‚ü¶ E ‚üß œÉ +' ‚ü¶ E' ‚üß œÉ where
  _+'_ : Maybe ‚Ñï ‚Üí Maybe ‚Ñï ‚Üí Maybe ‚Ñï
  just m +' just n = just (m + n)
  _      +'      _ = nothing

‚ü¶ if E then E‚Ä≤ else E‚Ä≥ ‚üß œÉ with ‚ü¶ E ‚üß œÉ
...  | just zero    = ‚ü¶ E‚Ä≥ ‚üß œÉ
...  | just (suc _) = ‚ü¶ E‚Ä≤ ‚üß œÉ
...  | nothing      = nothing
--‚ü¶ _ ‚üß _ = nothing

e0 : Exp ‚Ñï
e0 =  N(1) ‚äï N(1) ‚äï V("x")

x0 : Maybe ‚Ñï
x0 = ‚ü¶ e0 ‚üß (Œª v ‚Üí nothing)

x1 : Maybe ‚Ñï
x1 = ‚ü¶ e0 ‚üß (Œª v ‚Üí just 1)

--boolToNat : Exp ùîπ -> Exp ‚Ñï
--boolToNat (B true) = N (suc zero)
--boolToNat (B false) = N (zero)

compile : ‚àÄ {T} ‚Üí Exp T ‚Üí program
compile (N n)    = [ Val n ]
--compile (B b)    = [ boolToNat (B b) ]
compile (V s)    = [ Var s ]
compile (E ‚äï E') = (compile E ++ compile E') ++ [ Add ]
compile (if E then E' else  E'') = e ++ [ Joz (length p') ] ++ p' ++ e ++ [ Not ] ++ [ Joz (length p'') ] ++ p''
    where
    e = compile E
    p' = compile E'
    p'' = compile E''
compile E        = [ Err ]

x2 : Maybe stack
x2 = ‚ü®‚ü® compile e0 ‚ü©‚ü© [] , (Œª v ‚Üí just 1) , 10

{-
Example
  << Val 1 ‚à∑ Val 1 ‚à∑ Add ‚à∑ Var "x" ‚à∑ Add ‚à∑ [] >> [] --->
  << Val 1 ‚à∑ Add ‚à∑ Var "x" ‚à∑ Add ‚à∑ [] >> [1] -->
  << Add ‚à∑ Var "x" ‚à∑ Add ‚à∑ [] >> [1::1] -->
  << Var "x" ‚à∑ Add ‚à∑ [] >> [2] -->
  << Add ‚à∑ [] >> [1::2] -->
  << [] >> [3] -->
  just [3]
-}



{-
--anything that has not been defined in compile will just be Err 
sound : (T : Set) (e : Exp T) (p : program) (n : ‚Ñï)(œÉ : state) (k : ‚Ñï) ‚Üí
        ‚ü®‚ü® compile e ‚ü©‚ü© [] , œÉ , k ‚â° just [ n ] ‚Üí ‚ü¶ e ‚üß œÉ ‚â° just n 

--Booleans (Natalie)
sound .ùîπ (B x) p n œÉ zero () --can't have just [] ‚â° just [ n ] so false
sound .ùîπ (B x) p n œÉ (suc k) () --can't have  nothing ‚â° just [ n ]  so false  

--Constants (Natalie)
sound .‚Ñï (N x) p n œÉ zero ()  --can't have just [] ‚â° just n so false
sound .‚Ñï (N zero) p zero œÉ (suc k) pf = refl
sound .‚Ñï (N zero) p (suc n) œÉ (suc k) ()
sound .‚Ñï (N (suc x)) p .(suc x) œÉ (suc k) refl = refl

-- 
--‚ü®‚ü® Var x ‚à∑ p ‚ü©‚ü© s , œÉ , suc k with œÉ x
--...                            | just v  = ‚ü®‚ü® p ‚ü©‚ü© (v ‚à∑ s) , œÉ , k

--Variables (?)
sound .‚Ñï (V x) p n œÉ k q with œÉ x
sound .‚Ñï (V x) p n œÉ zero () | just v
sound .‚Ñï (V x) p n œÉ (suc k) q | just v = {!!}
... | nothing  = {!!}

 -- where 
{-   lemma3 : ‚ü®‚ü® [ Var x ] ‚ü©‚ü© [] , œÉ , k ‚â° just [ n ] ‚Üí œÉ x ‚â° just n
   lemma3 = {!!}-}

--Addition (?)
--‚ü®‚ü® (compile e ++ compile e‚ÇÅ) ++ [ Add ] ‚ü©‚ü© [] , œÉ , k ‚â° just [ n ] ‚Üí  (e _.+' e‚ÇÅ) œÉ (‚ü¶ e ‚üß œÉ) (‚ü¶ e‚ÇÅ ‚üß œÉ) ‚â° just n
sound .‚Ñï (e ‚äï e‚ÇÅ) p n œÉ k = {!!}

--Conditionals (?)
-- ‚ü®‚ü® [ Err ] ‚ü©‚ü© [] , œÉ , k ‚â° just [ n ] ‚Üí  (‚ü¶ if e then e‚ÇÅ else e‚ÇÇ ‚üß œÉ | ‚ü¶ e ‚üß œÉ) ‚â° just n
sound .‚Ñï (if_then_else e e‚ÇÅ e‚ÇÇ) p n œÉ k = {!!}
  
              
adeq : (T : Set) (e : Exp T) (p : program) (œÉ : state) (n : ‚Ñï) ‚Üí
        ‚ü¶ e ‚üß œÉ ‚â° just n ‚Üí (‚àÉ Œª k ‚Üí ‚ü®‚ü® compile e ‚ü©‚ü© [] , œÉ , k ‚â° just [ n ])
adeq .ùîπ (B x) p œÉ n x‚ÇÅ = {!!}
adeq .‚Ñï (N x) p œÉ n x‚ÇÅ = {!!}
adeq .‚Ñï (V x) p œÉ n x‚ÇÅ = {!!}
adeq .‚Ñï (e ‚äï e‚ÇÅ) p œÉ n x = {!!}
adeq .‚Ñï (if_then_else e e‚ÇÅ e‚ÇÇ) p œÉ n x = {!!}
              
adeq-fail : (T : Set) (e : Exp T) (p : program) (œÉ : state) (n : ‚Ñï) ‚Üí
        ‚ü¶ e ‚üß œÉ ‚â° nothing ‚Üí (‚àÉ Œª k ‚Üí ‚ü®‚ü® compile e ‚ü©‚ü© [] , œÉ , k ‚â° nothing)
adeq-fail = {!!}
-}


testiffalse : Exp ‚Ñï
testiffalse = (if (N( 0 )) then (N(1) ‚äï N(1)) else) (N ( 4 ))

testiftrue : Exp ‚Ñï
testiftrue = (if (N( 1 )) then (N(1) ‚äï N(1)) else) (N ( 4 ))

iftrueval : Maybe stack
iftrueval = ‚ü®‚ü® compile testiftrue ‚ü©‚ü© [] , (Œª x -> just zero) , 999

iffalseval : Maybe stack
iffalseval = ‚ü®‚ü® compile testiffalse ‚ü©‚ü© [] , (Œª x -> just zero) , 999

getVal : Maybe stack -> Maybe ‚Ñï
getVal nothing = nothing
getVal (just []) = nothing
getVal (just (n ‚à∑ t)) = just n

open import Data.Unit

main = run (putN (getVal(iftrueval)))
    where
    putN : Maybe ‚Ñï -> IO ‚ä§
    putN nothing = putStrLn ""
    putN (just n) = putStrLn (show n)
